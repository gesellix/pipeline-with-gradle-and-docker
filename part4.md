In part four of our series about our continuous deployment pipeline you'll learn about how we perform
contract tests to ensure our service stays compatible with other service producers and our consumers as well.

Please read the [introductury post](http://blog-it.hypoport.de/2014/07/25/a-continuous-deployment-pipeline-with-gradle-and-docker/)
to learn about the other articles and the overall context of our deployment pipeline.

# What are Contract Tests?

The comprehensive overview on [Testing Strategies in a Microservice Architecture](http://martinfowler.com/articles/microservice-testing/)
introduces [contract testing](http://martinfowler.com/articles/microservice-testing/#testing-contract-introduction) as complementary method
to increase test coverage:

Apart from unit, integration, component, and end-to-end tests, the contract tests aim at checking service boundaries.

Every consumer defines a set of criteria or requirements which need to be fulfilled by a service provider.
The sum of all requirements defines the overall service contract. With contract testing,
consumers can check the provider's contract or their own requirements before a new release is deployed in production.

The contract tests shouldn't check the provider's behaviour, but only verify that the API can be consumed.
Checking behaviour would result in component tests, which should be performed on the provider's
side and are not the responsibility of its consumers.

Contract tests should be performed either when the consumer changes or when the producer changes.
While it should be easy for every consumer to perform their own contract tests,
they should also provide a test package for the provider's pipeline or environment.
That way the provider can preview its own changes and their effect on every consumer.

# Contract Tests in real life

As easy as it sounds, performing contract tests in continuous deployment pipelines isn't trivial.

In our case services are written in Java, so we write our contract tests as Java unit tests,
using test runners like JUnit or TestNG and execute them with shell or Gradle scripts.
Packaging such test classes as *jar* files and publishing them in an artifact repository
belongs to the simple aspects. But making a provider available for contract tests
can become very exciting and produces several questions:

* can the tests be performed against the production service?
* what happens when tests need some setup (e.g. a user account) or need to have a valid session to consume the service API?
* do the tests have an effect on the overall service availablility?
* what about database entries being generated by the tests - do we need a cleanup?
* ...

With both consumer and provider in one team there's less communication necessary when concepts
or requirements are introduced or changed. When consumer and provider are split between
different teams or even companies, it becomes more important to define a clear API.
[Consumer-Driven Contracts](http://martinfowler.com/articles/consumerDrivenContracts.html#Consumer-drivenContracts) help the provider
to align their implementation at the consumer's needs.

To address the questions above, the provider might give the consumers a dedicated service
which behaves as much as possible like the productive instance.
